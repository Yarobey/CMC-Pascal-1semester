{$mode TP}
{$codepage UTF-8}
{$R+,B+,X-}

// ---------------------------------------------------------------------
// ЗАДАЧА (три этапа) (выход-8 от 18.12.2021)    Суммарно 120 очков
// РЕШАТЬ САМОСТОЯТЕЛЬНО, А НЕ КОЛЛЕКТИВНО (КАЖДЫЙ РАБОТАЕТ НА СЕБЯ !)
// ---------------------------------------------------------------------
(* ПОЭТАПНАЯ РАБОТА СО СПИСКОМ
Внимание! Можете описывать свои процедуры и функции как угодно 
(итеративно или рекурсивно), это дело вашего вкуса
НЕ ДОПУСКАТЬ УТЕЧКИ ПАМЯТИ, СДАВАЯ все ЭТАПЫ (использовать для этого
процедуру Destroy(L), написанную на предыдущем выходе-6).
Сдавать можно отдельными этапами или всю программу целиком.
------------------------------------------------------------------------
ЭТАП_1  (40 очков)
Построение по текстовому файлу matrix.txt списка L требуемого вида
------------------------------------------------------------------------
Дан внешний текстовый файл с именем matrix.txt, который содержит 
таблицу целых чисел размером n x n  (n задано в программе константой 
со значением 5). Программа  запрашивает у пользователя  целое число k
и по нему строит линейный список следующего вида:  сначала в списке 
(в отдельных звеньях)  должны располагаться элементы k-ой строки 
таблицы (в том же порядке, что и в таблице, т.е. слева направо), 
затем – элементы k-ого столбца таблицы (в противоположном порядке, 
т.е. снизу вверх).  

ОГРАНИЧЕНИЯ в решении ЭТАПА_1: 
1) в решении ЗАПРЕЩЕНО ИСПОЛЬЗОВАТЬ МАССИВЫ;  2) для считывания 
элементов таблицы следует  использовать ТОЛЬКО ЧИСЛОВОЙ ВВОД  вида 
read(t, x), где t – текстовый файл, х – целочисленная переменная;
3) таблицу (т.е. файл) можно просматривать ТОЛЬКО ОДИН РАЗ;  

ТРЕБОВАНИЯ к решению ЭТАПА_1: 
1) Описать функцию CreateList(t,k), которая по текстовому файлу t
(хранящему указанную выше таблицу) и целому числу k строит список 
требуемого вида и возвращает ссылку на построенный список. Если 
значение параметра k окажется вне диапазона от 1 до n, то функция 
возвращает значение nil . 2) Ссылку на построенный список присвоить 
переменной  L , описанной в основной программе. 3) Распечатать 
получившийся список  (описав предварительно процедуру  вывода 
элементов списка Print(L)). В случае пустого списка – вывести слово
“empty”.

ПОДСКАЗКА по реализации функции CreateList(t,k): построить два списка
(первый список строить от начала в конец, второй – от конца в начало)
и их объединить (соединив последнее звено первого списка с первым 
звеном второго списка). 

Содержимое файла matrix.txt должно соответствовать образцу, 
приведённому в конце этой программы (после точки).
Тесты, на которых будет проверяться работа программы, см. в самом
конце (после матрицы).

------------------------------------------------------------------------
ЭТАП_2  (40 очков)
Работа со списком, полученным после ЭТАПА_1
------------------------------------------------------------------------
За один просмотр полученного списка L удалить в нём все элементы, 
нарушающие УПОРЯДОЧЕННОСТЬ  этого списка ПО ВОЗРАСТАНИЮ (<), 
НАЧИНАЯ С ЕГО НАЧАЛА. Например: 
1) если список имел вид (10,13,16,19,8,5,14,20,19,3), то в
результате преобразований он станет таким: (10,13,16,19,20).
2) если список имел вид (1,1,1,1,1,1,1,1,1,1), то в результате 
преобразований он станет таким: (1).
3) если список имел вид (10,9,4,6,2,4,1,7,8,9), то в
результате преобразований он станет таким: (10).
4) если список имел вид (2,3,5,9,10,14,16,20,21,30), то в
результате преобразований он не изменится.
5) если список был пустым, то он не изменится.

ТРЕБОВАНИЯ к решению ЭТАПА_2: 
1) Описать процедуру  Remove(L) для удаления из списка L всех лишних 
элементов. 2) Вывести на экран полученный список, воспользовавшись
ранее написанной процедурой Print(L).  

------------------------------------------------------------------------
ЭТАП_3  (40 очков)
Работа со списком, полученным после ЭТАПА_2
------------------------------------------------------------------------
Проверить, образует ли полученный список L ВОЗРАСТАЮЩУЮ арифметическую 
прогрессию, состоящую из не менее двух элементов. Ответ на экране в 
виде: TRUE/FALSE. Если да, то ДОБАВИТЬ В КОНЕЦ СПИСКА НОВЫЙ ЭЛЕМЕНТ, 
являющийся очередным членом этой арифметической прогрессии. 

ТРЕБОВАНИЯ к решению ЭТАПА_3: 
1) Описать булевскую функцию IsArithm(L), выполняющую требуемую 
проверку. Функция, помимо проверки, в качестве “побочного эффекта”, 
добавляет, в случае необходимости, новый элемент в конец списка 
(внимание: в процессе работы данной функции ПО СПИСКУ разрешается 
пройтись ТОЛЬКО ОДИН РАЗ!). Если новый элемент был добавлен в конец 
списка, то по окончании работы функции IsArithm(L) вывести (из основной 
программы) на экран преобразованный список, воспользовавшись ранее 
написанной процедурой Print(L). Если нет - то на этом завершить работу 
программы. 

------------------------------------------------------------------------
Примечание: размер шрифта (в окне редактора и окне вывода следует 
УВЕЛИЧИТЬ, чтобы проверяющему всё было ВИДНО ХОРОШО.
------------------------------------------------------------------------
*)
program task(input, output);
uses heaptrc;        {подключение модуля контроля утечки памяти}
const
    n = 5;           {в текстовом файле matrix.txt задана 
                      целочисленная квадратная матрица n x n}
type
    TE = integer;
    list = ^node;
    node = record
        elem: TE;
        next: list
    end;
var 
    L: list;     {список, который следует построить}
    t: text;     {текстовый файл с матрицей чисел размером n x n}
    k: integer;  {значение k ввести с клавиатуры - для ЭТАПА_1}
    
//////////////////////////////////////////////////////////////////////
////   далее располагаются описания ваших процедур и функций      ////
//////////////////////////////////////////////////////////////////////
procedure destroy(var L: list);
var
    p: list;
begin
    if L <> nil then begin
        p := L;
        L := L^.next;
        dispose(p);
        destroy(L);
    end;
end;

procedure print(L: list);
begin
    if L <> nil then begin
        write(L^.elem,' ');
        {L := L^.next;}
        print(L^.next);
    end;
end;

function CreateList(var t: text; k: integer): list;
var
    L, L1, p, p1: list;
    i, j, x: integer;
    flag: boolean;
begin
    reset(t);
    L := nil;
    L1 := nil;
    flag := true;
    while (not eof(t)) and flag do begin
        if k in [1..n] then begin
            for i := 1 to n do begin
                if (not eoln(t)) and (not eof(t)) then begin
                    for j := 1 to n do begin
                        if not eoln(t) then
                            read(t, x);
                        if j = k then begin{строим столбец в обратном порядке}
                            new(p1);
                            p1^.elem := x;
                            p1^.next := L1;
                            L1 := p1;
                        end;
                        if i = k then begin{строим строку в прямом порядке}
                            if L = nil then begin
                                new(L);
                                L^.elem := x;
                                p := L;
                            end
                            else begin
                                new(p^.next);
                                p := p^.next;
                                p^.elem := x;
                            end;
                        end;
                    end;
                    readln(t);
                end;
            end;
        end
        else
            flag := false;
    end;
    if L <> nil then
        p^.next := L1;
    CreateList := L;
end;

procedure Remove(var L: list);
var
    p: list;
begin
    if L <> nil then begin
        if L^.next <> nil then begin
            if L^.elem >= L^.next^.elem then begin
                p := L^.next^.next;
                dispose(L^.next);
                L^.next := p;
                Remove(L);
            end
            else
                Remove(L^.next);
        end;
    end;
end;

function IsArithm(L: list): boolean;
var
    p: list;
    diff, diff1: integer;
    flag: boolean;
begin
    flag := true;
    if L <> nil then begin
        if L^.next <> nil then begin
            diff := L^.next^.elem - L^.elem;
            if L^.next^.next <> nil then begin
                L := L^.next;
                while (L^.next <> nil) and flag do begin
                    if (L^.next^.elem - L^.elem) <> diff then
                            flag := false;
                    if (L^.next <> nil) and flag then
                        L := L^.next;
                end;
            end
            else
                L := L^.next;
            if flag then begin
                new(p);
                p^.elem := L^.elem + diff;
                p^.next := nil;
                L^.next := p;
            end;
        end
        else
            flag := false;
    end
    else
        flag := false;
    IsArithm := flag;
end;

begin
    {содержимое раздела операторов - менять с учётом сдаваемых этапов}
    {обязательно выводить номер этапа, который сейчас выполняется}
    {содержимое раздела операторов - менять с учётом сдаваемых этапов}
    {обязательно выводить название этапа, который сейчас выполняется}
    writeln('===================');
    writeln('Task (list actions)');
    writeln('===================');
    writeln;
    writeln('part_1');
    {далее ваши операторы:}  
    write('Please, set "k": ');
    read(k);
    writeln;
    assign(t, 'matrix.txt');
    L := CreateList(t,k);
    if L <> nil then
        print(L)
    else
        write('"empty"');
    writeln;
    writeln;
    writeln('part_2');
    Remove(L);
    if L <> nil then
        print(L)
    else
        write('"empty"');
    writeln;
    writeln;
    writeln('part_3');
    if IsArithm(L) then begin
        writeln(true);
        print(L);
        writeln;
    end
    else
        writeln(false);
    destroy(L);
    close(t);                           {нужно для Фри-Паскаля}   
    writeln
end.

(* Содержимое файла matrix.txt (всего пять строк, в каждой - по 5 чисел):
10   10   10   10   10
10   12   14   16   18
10   9    8    7    6
10   20   30   20   30
10   5    10   40   50
*)

{
------------------------------------------------------------------------
                                ТЕСТЫ
------------------------------------------------------------------------
Тест_1: k=1
------------------------------------------------------------------------
после этапа_1:
10   10   10   10   10   10   10   10   10   10
после этапа_2:
10
после этапа_3:
FALSE
------------------------------------------------------------------------
Тест_2: k=2
------------------------------------------------------------------------
после этапа_1:
10   12   14   16   18   5   20   9   12   10
после этапа_2:
10   12   14   16   18   20 
после этапа_3:
TRUE
10   12   14   16   18   20   22
------------------------------------------------------------------------
Тест_3: k=3
------------------------------------------------------------------------
после этапа_1:
10   9    8    7    6   10   30   8   14   10
после этапа_2:
10   30 
после этапа_3:
TRUE
10   30   50
------------------------------------------------------------------------
Тест_4: k=4
------------------------------------------------------------------------
после этапа_1:
10   20   30   20   30   40   20   7    16    10
после этапа_2:
10   20   30   40 
после этапа_3:
TRUE
10   20   30   40    50
------------------------------------------------------------------------
Тест_5: k=5
------------------------------------------------------------------------
после этапа_1:
10   5    10   40   50   50   30   6   18  10
после этапа_2:
10   40    50
после этапа_3:
FALSE
------------------------------------------------------------------------
Тест_6: k=6 (>n)
------------------------------------------------------------------------
после этапа_1:
empty
после этапа_2:
empty
после этапа_3:
FALSE
------------------------------------------------------------------------
}




